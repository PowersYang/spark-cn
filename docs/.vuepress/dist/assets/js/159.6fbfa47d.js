(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{358:function(e,t,a){"use strict";a.r(t);var o=a(0),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"mapreduce-tutorial"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mapreduce-tutorial"}},[e._v("#")]),e._v(" MapReduce Tutorial")]),e._v(" "),a("h2",{attrs:{id:"purpose"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purpose"}},[e._v("#")]),e._v(" Purpose")]),e._v(" "),a("p",[e._v("This document comprehensively describes all user-facing facets of the Hadoop MapReduce framework and serves as a tutorial.")]),e._v(" "),a("h2",{attrs:{id:"prerequisites"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prerequisites"}},[e._v("#")]),e._v(" Prerequisites")]),e._v(" "),a("p",[e._v("Ensure that Hadoop is installed, configured and is running. More details:")]),e._v(" "),a("ul",[a("li",[a("p",[a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/SingleCluster.html"}},[e._v("Single Node Setup")]),e._v(" for first-time users.")],1)]),e._v(" "),a("li",[a("p",[a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/ClusterSetup.html"}},[e._v("Cluster Setup")]),e._v(" for large, distributed clusters.")],1)])]),e._v(" "),a("h2",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),a("p",[e._v("Hadoop MapReduce is a software framework for easily writing applications which process vast amounts of data (multi-terabyte data-sets) in-parallel on large clusters (thousands of nodes) of commodity hardware in a reliable, fault-tolerant manner.")]),e._v(" "),a("p",[e._v("A MapReduce job usually splits the input data-set into independent chunks which are processed by the map tasks in a completely parallel manner. The framework sorts the outputs of the maps, which are then input to the reduce tasks. Typically both the input and the output of the job are stored in a file-system. The framework takes care of scheduling tasks, monitoring them and re-executes the failed tasks.")]),e._v(" "),a("p",[e._v("Typically the compute nodes and the storage nodes are the same, that is, the MapReduce framework and the Hadoop Distributed File System (see "),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"}},[e._v("HDFS Architecture Guide")]),e._v(") are running on the same set of nodes. This configuration allows the framework to effectively schedule tasks on the nodes where data is already present, resulting in very high aggregate bandwidth across the cluster.")],1),e._v(" "),a("p",[e._v("The MapReduce framework consists of a single master ResourceManager, one worker NodeManager per cluster-node, and MRAppMaster per application (see "),a("router-link",{attrs:{to:"/en/docs/hadoop-yarn/hadoop-yarn-site/YARN.html"}},[e._v("YARN Architecture Guide")]),e._v(").")],1),e._v(" "),a("p",[e._v("Minimally, applications specify the input/output locations and supply map and reduce functions via implementations of appropriate interfaces and/or abstract-classes. These, and other job parameters, comprise the job configuration.")]),e._v(" "),a("p",[e._v("The Hadoop job client then submits the job (jar/executable etc.) and configuration to the ResourceManager which then assumes the responsibility of distributing the software/configuration to the workers, scheduling tasks and monitoring them, providing status and diagnostic information to the job-client.")]),e._v(" "),a("p",[e._v("Although the Hadoop framework is implemented in Java™, MapReduce applications need not be written in Java.")]),e._v(" "),a("ul",[a("li",[a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/streaming/package-summary.html"}},[e._v("Hadoop Streaming")]),e._v(" is a utility which allows users to create and run jobs with any executables (e.g. shell utilities) as the mapper and/or the reducer.")],1)]),e._v(" "),a("li",[a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/pipes/package-summary.html"}},[e._v("Hadoop Pipes")]),e._v(" is a "),a("a",{attrs:{href:"http://www.swig.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("SWIG"),a("OutboundLink")],1),e._v("-compatible C++ API to implement MapReduce applications (non JNI™ based).")],1)])]),e._v(" "),a("h2",{attrs:{id:"inputs-and-outputs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inputs-and-outputs"}},[e._v("#")]),e._v(" Inputs and Outputs")]),e._v(" "),a("p",[e._v("The MapReduce framework operates exclusively on <key, value> pairs, that is, the framework views the input to the job as a set of <key, value> pairs and produces a set of <key, value> pairs as the output of the job, conceivably of different types.")]),e._v(" "),a("p",[e._v("The key and value classes have to be serializable by the framework and hence need to implement the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/io/Writable.html"}},[e._v("Writable")]),e._v(" interface. Additionally, the key classes have to implement the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/io/WritableComparable.html"}},[e._v("WritableComparable")]),e._v(" interface to facilitate sorting by the framework.")],1),e._v(" "),a("p",[e._v("Input and Output types of a MapReduce job:")]),e._v(" "),a("p",[e._v("(input) <k1, v1> -> map -> <k2, v2> -> combine -> <k2, v2> -> reduce -> <k3, v3> (output)")]),e._v(" "),a("h2",{attrs:{id:"example-wordcount-v1-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-wordcount-v1-0"}},[e._v("#")]),e._v(" Example: WordCount v1.0")]),e._v(" "),a("p",[e._v("Before we jump into the details, lets walk through an example MapReduce application to get a flavour for how they work.")]),e._v(" "),a("p",[e._v("WordCount is a simple application that counts the number of occurrences of each word in a given input set.")]),e._v(" "),a("p",[e._v("This works with a local-standalone, pseudo-distributed or fully-distributed Hadoop installation ("),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/SingleCluster.html"}},[e._v("Single Node Setup")]),e._v(").")],1),e._v(" "),a("h3",{attrs:{id:"source-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#source-code"}},[e._v("#")]),e._v(" Source Code")]),e._v(" "),a("pre",[a("code",[e._v('import java.io.IOException;\nimport java.util.StringTokenizer;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\n\npublic class WordCount {\n\n  public static class TokenizerMapper\n       extends Mapper<Object, Text, Text, IntWritable>{\n\n    private final static IntWritable one = new IntWritable(1);\n    private Text word = new Text();\n\n    public void map(Object key, Text value, Context context\n                    ) throws IOException, InterruptedException {\n      StringTokenizer itr = new StringTokenizer(value.toString());\n      while (itr.hasMoreTokens()) {\n        word.set(itr.nextToken());\n        context.write(word, one);\n      }\n    }\n  }\n\n  public static class IntSumReducer\n       extends Reducer<Text,IntWritable,Text,IntWritable> {\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values,\n                       Context context\n                       ) throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    Configuration conf = new Configuration();\n    Job job = Job.getInstance(conf, "word count");\n    job.setJarByClass(WordCount.class);\n    job.setMapperClass(TokenizerMapper.class);\n    job.setCombinerClass(IntSumReducer.class);\n    job.setReducerClass(IntSumReducer.class);\n    job.setOutputKeyClass(Text.class);\n    job.setOutputValueClass(IntWritable.class);\n    FileInputFormat.addInputPath(job, new Path(args[0]));\n    FileOutputFormat.setOutputPath(job, new Path(args[1]));\n    System.exit(job.waitForCompletion(true) ? 0 : 1);\n  }\n}\n')])]),e._v(" "),a("h3",{attrs:{id:"usage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usage"}},[e._v("#")]),e._v(" Usage")]),e._v(" "),a("p",[e._v("Assuming environment variables are set as follows:")]),e._v(" "),a("pre",[a("code",[e._v("export JAVA_HOME=/usr/java/default\nexport PATH=${JAVA_HOME}/bin:${PATH}\nexport HADOOP_CLASSPATH=${JAVA_HOME}/lib/tools.jar\n")])]),e._v(" "),a("p",[e._v("Compile WordCount.java and create a jar:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop com.sun.tools.javac.Main WordCount.java\n$ jar cf wc.jar WordCount*.class\n")])]),e._v(" "),a("p",[e._v("Assuming that:")]),e._v(" "),a("ul",[a("li",[e._v("/user/joe/wordcount/input - input directory in HDFS")]),e._v(" "),a("li",[e._v("/user/joe/wordcount/output - output directory in HDFS")])]),e._v(" "),a("p",[e._v("Sample text-files as input:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop fs -ls /user/joe/wordcount/input/\n/user/joe/wordcount/input/file01\n/user/joe/wordcount/input/file02\n\n$ bin/hadoop fs -cat /user/joe/wordcount/input/file01\nHello World Bye World\n\n$ bin/hadoop fs -cat /user/joe/wordcount/input/file02\nHello Hadoop Goodbye Hadoop\n")])]),e._v(" "),a("p",[e._v("Run the application:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop jar wc.jar WordCount /user/joe/wordcount/input /user/joe/wordcount/output\n")])]),e._v(" "),a("p",[e._v("Output:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000\nBye 1\nGoodbye 1\nHadoop 2\nHello 2\nWorld 2\n")])]),e._v(" "),a("p",[e._v("Applications can specify a comma separated list of paths which would be present in the current working directory of the task using the option -files. The -libjars option allows applications to add jars to the classpaths of the maps and reduces. The option -archives allows them to pass comma separated list of archives as arguments. These archives are unarchived and a link with name of the archive is created in the current working directory of tasks. More details about the command line options are available at "),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/CommandsManual.html"}},[e._v("Commands Guide")]),e._v(".")],1),e._v(" "),a("p",[e._v("Running wordcount example with -libjars, -files and -archives:")]),e._v(" "),a("pre",[a("code",[e._v("bin/hadoop jar hadoop-mapreduce-examples-<ver>.jar wordcount -files cachefile.txt -libjars mylib.jar -archives myarchive.zip input output\n")])]),e._v(" "),a("p",[e._v("Here, myarchive.zip will be placed and unzipped into a directory by the name “myarchive.zip”.")]),e._v(" "),a("p",[e._v("Users can specify a different symbolic name for files and archives passed through -files and -archives option, using #.")]),e._v(" "),a("p",[e._v("For example,")]),e._v(" "),a("pre",[a("code",[e._v("bin/hadoop jar hadoop-mapreduce-examples-<ver>.jar wordcount -files dir1/dict.txt#dict1,dir2/dict.txt#dict2 -archives mytar.tgz#tgzdir input output\n")])]),e._v(" "),a("p",[e._v("Here, the files dir1/dict.txt and dir2/dict.txt can be accessed by tasks using the symbolic names dict1 and dict2 respectively. The archive mytar.tgz will be placed and unarchived into a directory by the name “tgzdir”.")]),e._v(" "),a("p",[e._v("Applications can specify environment variables for mapper, reducer, and application master tasks by specifying them on the command line using the options -Dmapreduce.map.env, -Dmapreduce.reduce.env, and -Dyarn.app.mapreduce.am.env, respectively.")]),e._v(" "),a("p",[e._v("For example the following sets environment variables FOO_VAR=bar and LIST_VAR=a,b,c for the mappers and reducers,")]),e._v(" "),a("pre",[a("code",[e._v("bin/hadoop jar hadoop-mapreduce-examples-<ver>.jar wordcount -Dmapreduce.map.env.FOO_VAR=bar -Dmapreduce.map.env.LIST_VAR=a,b,c -Dmapreduce.reduce.env.FOO_VAR=bar -Dmapreduce.reduce.env.LIST_VAR=a,b,c input output\n")])]),e._v(" "),a("h3",{attrs:{id:"walk-through"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#walk-through"}},[e._v("#")]),e._v(" Walk-through")]),e._v(" "),a("p",[e._v("The WordCount application is quite straight-forward.")]),e._v(" "),a("pre",[a("code",[e._v("public void map(Object key, Text value, Context context\n                ) throws IOException, InterruptedException {\n  StringTokenizer itr = new StringTokenizer(value.toString());\n  while (itr.hasMoreTokens()) {\n    word.set(itr.nextToken());\n    context.write(word, one);\n  }\n}\n")])]),e._v(" "),a("p",[e._v("The Mapper implementation, via the map method, processes one line at a time, as provided by the specified TextInputFormat. It then splits the line into tokens separated by whitespaces, via the StringTokenizer, and emits a key-value pair of < "),a("word",[e._v(", 1>.")])],1),e._v(" "),a("p",[e._v("For the given sample input the first map emits:")]),e._v(" "),a("pre",[a("code",[e._v("< Hello, 1>\n< World, 1>\n< Bye, 1>\n< World, 1>\n")])]),e._v(" "),a("p",[e._v("The second map emits:")]),e._v(" "),a("pre",[a("code",[e._v("< Hello, 1>\n< Hadoop, 1>\n< Goodbye, 1>\n< Hadoop, 1>\n")])]),e._v(" "),a("p",[e._v("We’ll learn more about the number of maps spawned for a given job, and how to control them in a fine-grained manner, a bit later in the tutorial.")]),e._v(" "),a("pre",[a("code",[e._v("    job.setCombinerClass(IntSumReducer.class);\n")])]),e._v(" "),a("p",[e._v("WordCount also specifies a combiner. Hence, the output of each map is passed through the local combiner (which is same as the Reducer as per the job configuration) for local aggregation, after being sorted on the keys.")]),e._v(" "),a("p",[e._v("The output of the first map:")]),e._v(" "),a("pre",[a("code",[e._v("< Bye, 1>\n< Hello, 1>\n< World, 2>\n")])]),e._v(" "),a("p",[e._v("The output of the second map:")]),e._v(" "),a("pre",[a("code",[e._v("< Goodbye, 1>\n< Hadoop, 2>\n< Hello, 1>\n\n\n\npublic void reduce(Text key, Iterable<IntWritable> values,\n                   Context context\n                   ) throws IOException, InterruptedException {\n  int sum = 0;\n  for (IntWritable val : values) {\n    sum += val.get();\n  }\n  result.set(sum);\n  context.write(key, result);\n}\n")])]),e._v(" "),a("p",[e._v("The Reducer implementation, via the reduce method just sums up the values, which are the occurrence counts for each key (i.e. words in this example).")]),e._v(" "),a("p",[e._v("Thus the output of the job is:")]),e._v(" "),a("pre",[a("code",[e._v("< Bye, 1>\n< Goodbye, 1>\n< Hadoop, 2>\n< Hello, 2>\n< World, 2>\n")])]),e._v(" "),a("p",[e._v("The main method specifies various facets of the job, such as the input/output paths (passed via the command line), key/value types, input/output formats etc., in the Job. It then calls the job.waitForCompletion to submit the job and monitor its progress.")]),e._v(" "),a("p",[e._v("We’ll learn more about Job, InputFormat, OutputFormat and other interfaces and classes a bit later in the tutorial.")]),e._v(" "),a("h2",{attrs:{id:"mapreduce-user-interfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mapreduce-user-interfaces"}},[e._v("#")]),e._v(" MapReduce - User Interfaces")]),e._v(" "),a("p",[e._v("This section provides a reasonable amount of detail on every user-facing aspect of the MapReduce framework. This should help users implement, configure and tune their jobs in a fine-grained manner. However, please note that the javadoc for each class/interface remains the most comprehensive documentation available; this is only meant to be a tutorial.")]),e._v(" "),a("p",[e._v("Let us first take the Mapper and Reducer interfaces. Applications typically implement them to provide the map and reduce methods.")]),e._v(" "),a("p",[e._v("We will then discuss other core interfaces including Job, Partitioner, InputFormat, OutputFormat, and others.")]),e._v(" "),a("p",[e._v("Finally, we will wrap up by discussing some useful features of the framework such as the DistributedCache, IsolationRunner etc.")]),e._v(" "),a("h3",{attrs:{id:"payload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#payload"}},[e._v("#")]),e._v(" Payload")]),e._v(" "),a("p",[e._v("Applications typically implement the Mapper and Reducer interfaces to provide the map and reduce methods. These form the core of the job.")]),e._v(" "),a("h4",{attrs:{id:"mapper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mapper"}},[e._v("#")]),e._v(" Mapper")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Mapper.html"}},[e._v("Mapper")]),e._v(" maps input key/value pairs to a set of intermediate key/value pairs.")],1),e._v(" "),a("p",[e._v("Maps are the individual tasks that transform input records into intermediate records. The transformed intermediate records do not need to be of the same type as the input records. A given input pair may map to zero or many output pairs.")]),e._v(" "),a("p",[e._v("The Hadoop MapReduce framework spawns one map task for each InputSplit generated by the InputFormat for the job.")]),e._v(" "),a("p",[e._v("Overall, mapper implementations are passed to the job via "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setMapperClass(Class)")]),e._v(" method. The framework then calls "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Mapper.html"}},[e._v("map(WritableComparable, Writable, Context)")]),e._v(" for each key/value pair in the InputSplit for that task. Applications can then override the cleanup(Context) method to perform any required cleanup.")],1),e._v(" "),a("p",[e._v("Output pairs do not need to be of the same types as input pairs. A given input pair may map to zero or many output pairs. Output pairs are collected with calls to context.write(WritableComparable, Writable).")]),e._v(" "),a("p",[e._v("Applications can use the Counter to report its statistics.")]),e._v(" "),a("p",[e._v("All intermediate values associated with a given output key are subsequently grouped by the framework, and passed to the Reducer(s) to determine the final output. Users can control the grouping by specifying a Comparator via "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setGroupingComparatorClass(Class)")]),e._v(".")],1),e._v(" "),a("p",[e._v("The Mapper outputs are sorted and then partitioned per Reducer. The total number of partitions is the same as the number of reduce tasks for the job. Users can control which keys (and hence records) go to which Reducer by implementing a custom Partitioner.")]),e._v(" "),a("p",[e._v("Users can optionally specify a combiner, via "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setCombinerClass(Class)")]),e._v(", to perform local aggregation of the intermediate outputs, which helps to cut down the amount of data transferred from the Mapper to the Reducer.")],1),e._v(" "),a("p",[e._v("The intermediate, sorted outputs are always stored in a simple (key-len, key, value-len, value) format. Applications can control if, and how, the intermediate outputs are to be compressed and the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/io/compress/CompressionCodec.html"}},[e._v("CompressionCodec")]),e._v(" to be used via the Configuration.")],1),e._v(" "),a("h5",{attrs:{id:"how-many-maps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-many-maps"}},[e._v("#")]),e._v(" How Many Maps?")]),e._v(" "),a("p",[e._v("The number of maps is usually driven by the total size of the inputs, that is, the total number of blocks of the input files.")]),e._v(" "),a("p",[e._v("The right level of parallelism for maps seems to be around 10-100 maps per-node, although it has been set up to 300 maps for very cpu-light map tasks. Task setup takes a while, so it is best if the maps take at least a minute to execute.")]),e._v(" "),a("p",[e._v("Thus, if you expect 10TB of input data and have a blocksize of 128MB, you’ll end up with 82,000 maps, unless Configuration.set(MRJobConfig.NUM_MAPS, int) (which only provides a hint to the framework) is used to set it even higher.")]),e._v(" "),a("h4",{attrs:{id:"reducer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reducer"}},[e._v("#")]),e._v(" Reducer")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Reducer.html"}},[e._v("Reducer")]),e._v(" reduces a set of intermediate values which share a key to a smaller set of values.")],1),e._v(" "),a("p",[e._v("The number of reduces for the job is set by the user via "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setNumReduceTasks(int)")]),e._v(".")],1),e._v(" "),a("p",[e._v("Overall, Reducer implementations are passed the Job for the job via the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setReducerClass(Class)")]),e._v(" method and can override it to initialize themselves. The framework then calls "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Reducer.html"}},[e._v("reduce(WritableComparable, Iterable"),a("Writable",[e._v(", Context)")])],1),e._v(" method for each <key, (list of values)> pair in the grouped inputs. Applications can then override the cleanup(Context) method to perform any required cleanup.")],1),e._v(" "),a("p",[e._v("Reducer has 3 primary phases: shuffle, sort and reduce.")]),e._v(" "),a("h5",{attrs:{id:"shuffle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shuffle"}},[e._v("#")]),e._v(" Shuffle")]),e._v(" "),a("p",[e._v("Input to the Reducer is the sorted output of the mappers. In this phase the framework fetches the relevant partition of the output of all the mappers, via HTTP.")]),e._v(" "),a("h5",{attrs:{id:"sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sort"}},[e._v("#")]),e._v(" Sort")]),e._v(" "),a("p",[e._v("The framework groups Reducer inputs by keys (since different mappers may have output the same key) in this stage.")]),e._v(" "),a("p",[e._v("The shuffle and sort phases occur simultaneously; while map-outputs are being fetched they are merged.")]),e._v(" "),a("h5",{attrs:{id:"secondary-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#secondary-sort"}},[e._v("#")]),e._v(" Secondary Sort")]),e._v(" "),a("p",[e._v("If equivalence rules for grouping the intermediate keys are required to be different from those for grouping keys before reduction, then one may specify a Comparator via "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setSortComparatorClass(Class)")]),e._v(". Since "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setGroupingComparatorClass(Class)")]),e._v(" can be used to control how intermediate keys are grouped, these can be used in conjunction to simulate secondary sort on values.")],1),e._v(" "),a("h5",{attrs:{id:"reduce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[e._v("#")]),e._v(" Reduce")]),e._v(" "),a("p",[e._v("In this phase the reduce(WritableComparable, Iterable"),a("Writable",[e._v(", Context) method is called for each <key, (list of values)> pair in the grouped inputs.")])],1),e._v(" "),a("p",[e._v("The output of the reduce task is typically written to the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/fs/FileSystem.html"}},[e._v("FileSystem")]),e._v(" via Context.write(WritableComparable, Writable).")],1),e._v(" "),a("p",[e._v("Applications can use the Counter to report its statistics.")]),e._v(" "),a("p",[e._v("The output of the Reducer is not sorted.")]),e._v(" "),a("h5",{attrs:{id:"how-many-reduces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-many-reduces"}},[e._v("#")]),e._v(" How Many Reduces?")]),e._v(" "),a("p",[e._v("The right number of reduces seems to be 0.95 or 1.75 multiplied by (<no. of nodes> * <no. of maximum containers per node>).")]),e._v(" "),a("p",[e._v("With 0.95 all of the reduces can launch immediately and start transferring map outputs as the maps finish. With 1.75 the faster nodes will finish their first round of reduces and launch a second wave of reduces doing a much better job of load balancing.")]),e._v(" "),a("p",[e._v("Increasing the number of reduces increases the framework overhead, but increases load balancing and lowers the cost of failures.")]),e._v(" "),a("p",[e._v("The scaling factors above are slightly less than whole numbers to reserve a few reduce slots in the framework for speculative-tasks and failed tasks.")]),e._v(" "),a("h5",{attrs:{id:"reducer-none"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reducer-none"}},[e._v("#")]),e._v(" Reducer NONE")]),e._v(" "),a("p",[e._v("It is legal to set the number of reduce-tasks to zero if no reduction is desired.")]),e._v(" "),a("p",[e._v("In this case the outputs of the map-tasks go directly to the FileSystem, into the output path set by "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html"}},[e._v("FileOutputFormat.setOutputPath(Job, Path)")]),e._v(". The framework does not sort the map-outputs before writing them out to the FileSystem.")],1),e._v(" "),a("h4",{attrs:{id:"partitioner"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#partitioner"}},[e._v("#")]),e._v(" Partitioner")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Partitioner.html"}},[e._v("Partitioner")]),e._v(" partitions the key space.")],1),e._v(" "),a("p",[e._v("Partitioner controls the partitioning of the keys of the intermediate map-outputs. The key (or a subset of the key) is used to derive the partition, typically by a hash function. The total number of partitions is the same as the number of reduce tasks for the job. Hence this controls which of the m reduce tasks the intermediate key (and hence the record) is sent to for reduction.")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/partition/HashPartitioner.html"}},[e._v("HashPartitioner")]),e._v(" is the default Partitioner.")],1),e._v(" "),a("h4",{attrs:{id:"counter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#counter"}},[e._v("#")]),e._v(" Counter")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Counter.html"}},[e._v("Counter")]),e._v(" is a facility for MapReduce applications to report its statistics.")],1),e._v(" "),a("p",[e._v("Mapper and Reducer implementations can use the Counter to report statistics.")]),e._v(" "),a("p",[e._v("Hadoop MapReduce comes bundled with a "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/package-summary.html"}},[e._v("library")]),e._v(" of generally useful mappers, reducers, and partitioners.")],1),e._v(" "),a("h3",{attrs:{id:"job-configuration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job-configuration"}},[e._v("#")]),e._v(" Job Configuration")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job")]),e._v(" represents a MapReduce job configuration.")],1),e._v(" "),a("p",[e._v("Job is the primary interface for a user to describe a MapReduce job to the Hadoop framework for execution. The framework tries to faithfully execute the job as described by Job, however:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Some configuration parameters may have been marked as final by administrators (see "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/conf/Configuration.html#FinalParams"}},[e._v("Final Parameters")]),e._v(") and hence cannot be altered.")],1)]),e._v(" "),a("li",[a("p",[e._v("While some job parameters are straight-forward to set (e.g. "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setNumReduceTasks(int)")]),e._v(") , other parameters interact subtly with the rest of the framework and/or job configuration and are more complex to set (e.g. "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/conf/Configuration.html"}},[e._v("Configuration.set(JobContext.NUM_MAPS, int)")]),e._v(").")],1)])]),e._v(" "),a("p",[e._v("Job is typically used to specify the Mapper, combiner (if any), Partitioner, Reducer, InputFormat, OutputFormat implementations. "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html"}},[e._v("FileInputFormat")]),e._v(" indicates the set of input files ("),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html"}},[e._v("FileInputFormat.setInputPaths(Job, Path…)")]),e._v("/ "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html"}},[e._v("FileInputFormat.addInputPath(Job, Path)")]),e._v(") and ("),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html"}},[e._v("FileInputFormat.setInputPaths(Job, String…)")]),e._v("/ "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html"}},[e._v("FileInputFormat.addInputPaths(Job, String))")]),e._v(" and where the output files should be written ("),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html"}},[e._v("FileOutputFormat.setOutputPath(Path)")]),e._v(").")],1),e._v(" "),a("p",[e._v("Optionally, Job is used to specify other advanced facets of the job such as the Comparator to be used, files to be put in the DistributedCache, whether intermediate and/or job outputs are to be compressed (and how), whether job tasks can be executed in a speculative manner ("),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("setMapSpeculativeExecution(boolean)")]),e._v(")/ "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("setReduceSpeculativeExecution(boolean)")]),e._v("), maximum number of attempts per task ("),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("setMaxMapAttempts(int)")]),e._v("/ "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("setMaxReduceAttempts(int)")]),e._v(") etc.")],1),e._v(" "),a("p",[e._v("Of course, users can use "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/conf/Configuration.html"}},[e._v("Configuration.set(String, String)")]),e._v("/ "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/conf/Configuration.html"}},[e._v("Configuration.get(String)")]),e._v(" to set/get arbitrary parameters needed by applications. However, use the DistributedCache for large amounts of (read-only) data.")],1),e._v(" "),a("h3",{attrs:{id:"task-execution-environment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task-execution-environment"}},[e._v("#")]),e._v(" Task Execution & Environment")]),e._v(" "),a("p",[e._v("The MRAppMaster executes the Mapper/Reducer task as a child process in a separate jvm.")]),e._v(" "),a("p",[e._v("The child-task inherits the environment of the parent MRAppMaster. The user can specify additional options to the child-jvm via the mapreduce.{map|reduce}.java.opts and configuration parameter in the Job such as non-standard paths for the run-time linker to search shared libraries via -Djava.library.path=<> etc. If the mapreduce.{map|reduce}.java.opts parameters contains the symbol @taskid@ it is interpolated with value of taskid of the MapReduce task.")]),e._v(" "),a("p",[e._v("Here is an example with multiple arguments and substitutions, showing jvm GC logging, and start of a passwordless JVM JMX agent so that it can connect with jconsole and the likes to watch child memory, threads and get thread dumps. It also sets the maximum heap-size of the map and reduce child jvm to 512MB & 1024MB respectively. It also adds an additional path to the java.library.path of the child-jvm.")]),e._v(" "),a("pre",[a("code",[e._v("<property>\n  <name>mapreduce.map.java.opts</name>\n  <value>\n  -Xmx512M -Djava.library.path=/home/mycompany/lib -verbose:gc -Xloggc:/tmp/@taskid@.gc\n  -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false\n  </value>\n</property>\n\n<property>\n  <name>mapreduce.reduce.java.opts</name>\n  <value>\n  -Xmx1024M -Djava.library.path=/home/mycompany/lib -verbose:gc -Xloggc:/tmp/@taskid@.gc\n  -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false\n  </value>\n</property>\n")])]),e._v(" "),a("h4",{attrs:{id:"memory-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memory-management"}},[e._v("#")]),e._v(" Memory Management")]),e._v(" "),a("p",[e._v("Users/admins can also specify the maximum virtual memory of the launched child-task, and any sub-process it launches recursively, using mapreduce.{map|reduce}.memory.mb. Note that the value set here is a per process limit. The value for mapreduce.{map|reduce}.memory.mb should be specified in mega bytes (MB). And also the value must be greater than or equal to the -Xmx passed to JavaVM, else the VM might not start.")]),e._v(" "),a("p",[e._v("Note: mapreduce.{map|reduce}.java.opts are used only for configuring the launched child tasks from MRAppMaster. Configuring the memory options for daemons is documented in "),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/ClusterSetup.html#Configuring_Environment_of_Hadoop_Daemons"}},[e._v("Configuring the Environment of the Hadoop Daemons")]),e._v(".")],1),e._v(" "),a("p",[e._v("The memory available to some parts of the framework is also configurable. In map and reduce tasks, performance may be influenced by adjusting parameters influencing the concurrency of operations and the frequency with which data will hit disk. Monitoring the filesystem counters for a job- particularly relative to byte counts from the map and into the reduce- is invaluable to the tuning of these parameters.")]),e._v(" "),a("h4",{attrs:{id:"map-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-parameters"}},[e._v("#")]),e._v(" Map Parameters")]),e._v(" "),a("p",[e._v("A record emitted from a map will be serialized into a buffer and metadata will be stored into accounting buffers. As described in the following options, when either the serialization buffer or the metadata exceed a threshold, the contents of the buffers will be sorted and written to disk in the background while the map continues to output records. If either buffer fills completely while the spill is in progress, the map thread will block. When the map is finished, any remaining records are written to disk and all on-disk segments are merged into a single file. Minimizing the number of spills to disk can decrease map time, but a larger buffer also decreases the memory available to the mapper.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Name")]),e._v(" "),a("th",[e._v("Type")]),e._v(" "),a("th",[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("mapreduce.task.io.sort.mb")]),e._v(" "),a("td",[e._v("int")]),e._v(" "),a("td",[e._v("The cumulative size of the serialization and accounting buffers storing records emitted from the map, in megabytes.")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.map.sort.spill.percent")]),e._v(" "),a("td",[e._v("float")]),e._v(" "),a("td",[e._v("The soft limit in the serialization buffer. Once reached, a thread will begin to spill the contents to disk in the background.")])])])]),e._v(" "),a("p",[e._v("Other notes")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("If either spill threshold is exceeded while a spill is in progress, collection will continue until the spill is finished. For example, if mapreduce.map.sort.spill.percent is set to 0.33, and the remainder of the buffer is filled while the spill runs, the next spill will include all the collected records, or 0.66 of the buffer, and will not generate additional spills. In other words, the thresholds are defining triggers, not blocking.")])]),e._v(" "),a("li",[a("p",[e._v("A record larger than the serialization buffer will first trigger a spill, then be spilled to a separate file. It is undefined whether or not this record will first pass through the combiner.")])])]),e._v(" "),a("h4",{attrs:{id:"shuffle-reduce-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shuffle-reduce-parameters"}},[e._v("#")]),e._v(" Shuffle/Reduce Parameters")]),e._v(" "),a("p",[e._v("As described previously, each reduce fetches the output assigned to it by the Partitioner via HTTP into memory and periodically merges these outputs to disk. If intermediate compression of map outputs is turned on, each output is decompressed into memory. The following options affect the frequency of these merges to disk prior to the reduce and the memory allocated to map output during the reduce.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Name")]),e._v(" "),a("th",[e._v("Type")]),e._v(" "),a("th",[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("mapreduce.task.io.soft.factor")]),e._v(" "),a("td",[e._v("int")]),e._v(" "),a("td",[e._v("Specifies the number of segments on disk to be merged at the same time. It limits the number of open files and compression codecs during merge. If the number of files exceeds this limit, the merge will proceed in several passes. Though this limit also applies to the map, most jobs should be configured so that hitting this limit is unlikely there.")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.reduce.merge.inmem.thresholds")]),e._v(" "),a("td",[e._v("int")]),e._v(" "),a("td",[e._v("The number of sorted map outputs fetched into memory before being merged to disk. Like the spill thresholds in the preceding note, this is not defining a unit of partition, but a trigger. In practice, this is usually set very high (1000) or disabled (0), since merging in-memory segments is often less expensive than merging from disk (see notes following this table). This threshold influences only the frequency of in-memory merges during the shuffle.")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.reduce.shuffle.merge.percent")]),e._v(" "),a("td",[e._v("float")]),e._v(" "),a("td",[e._v("The memory threshold for fetched map outputs before an in-memory merge is started, expressed as a percentage of memory allocated to storing map outputs in memory. Since map outputs that can’t fit in memory can be stalled, setting this high may decrease parallelism between the fetch and merge. Conversely, values as high as 1.0 have been effective for reduces whose input can fit entirely in memory. This parameter influences only the frequency of in-memory merges during the shuffle.")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.reduce.shuffle.input.buffer.percent")]),e._v(" "),a("td",[e._v("float")]),e._v(" "),a("td",[e._v("The percentage of memory- relative to the maximum heapsize as typically specified in mapreduce.reduce.java.opts- that can be allocated to storing map outputs during the shuffle. Though some memory should be set aside for the framework, in general it is advantageous to set this high enough to store large and numerous map outputs.")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.reduce.input.buffer.percent")]),e._v(" "),a("td",[e._v("float")]),e._v(" "),a("td",[e._v("The percentage of memory relative to the maximum heapsize in which map outputs may be retained during the reduce. When the reduce begins, map outputs will be merged to disk until those that remain are under the resource limit this defines. By default, all map outputs are merged to disk before the reduce begins to maximize the memory available to the reduce. For less memory-intensive reduces, this should be increased to avoid trips to disk.")])])])]),e._v(" "),a("p",[e._v("Other notes")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("If a map output is larger than 25 percent of the memory allocated to copying map outputs, it will be written directly to disk without first staging through memory.")])]),e._v(" "),a("li",[a("p",[e._v("When running with a combiner, the reasoning about high merge thresholds and large buffers may not hold. For merges started before all map outputs have been fetched, the combiner is run while spilling to disk. In some cases, one can obtain better reduce times by spending resources combining map outputs- making disk spills small and parallelizing spilling and fetching- rather than aggressively increasing buffer sizes.")])]),e._v(" "),a("li",[a("p",[e._v("When merging in-memory map outputs to disk to begin the reduce, if an intermediate merge is necessary because there are segments to spill and at least mapreduce.task.io.sort.factor segments already on disk, the in-memory map outputs will be part of the intermediate merge.")])])]),e._v(" "),a("h4",{attrs:{id:"configured-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#configured-parameters"}},[e._v("#")]),e._v(" Configured Parameters")]),e._v(" "),a("p",[e._v("The following properties are localized in the job configuration for each task’s execution:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Name")]),e._v(" "),a("th",[e._v("Type")]),e._v(" "),a("th",[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("mapreduce.job.id")]),e._v(" "),a("td",[e._v("String")]),e._v(" "),a("td",[e._v("The job id")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.job.jar")]),e._v(" "),a("td",[e._v("String")]),e._v(" "),a("td",[e._v("job.jar location in job directory")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.job.local.dir")]),e._v(" "),a("td",[e._v("String")]),e._v(" "),a("td",[e._v("The job specific shared scratch space")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.task.id")]),e._v(" "),a("td",[e._v("String")]),e._v(" "),a("td",[e._v("The task id")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.task.attempt.id")]),e._v(" "),a("td",[e._v("String")]),e._v(" "),a("td",[e._v("The task attempt id")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.task.is.map")]),e._v(" "),a("td",[e._v("boolean")]),e._v(" "),a("td",[e._v("Is this a map task")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.task.partition")]),e._v(" "),a("td",[e._v("int")]),e._v(" "),a("td",[e._v("The id of the task within the job")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.map.input.file")]),e._v(" "),a("td",[e._v("String")]),e._v(" "),a("td",[e._v("The filename that the map is reading from")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.map.input.start")]),e._v(" "),a("td",[e._v("long")]),e._v(" "),a("td",[e._v("The offset of the start of the map input split")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.map.input.length")]),e._v(" "),a("td",[e._v("long")]),e._v(" "),a("td",[e._v("The number of bytes in the map input split")])]),e._v(" "),a("tr",[a("td",[e._v("mapreduce.task.output.dir")]),e._v(" "),a("td",[e._v("String")]),e._v(" "),a("td",[e._v("The task’s temporary output directory")])])])]),e._v(" "),a("p",[e._v("Note: During the execution of a streaming job, the names of the “mapreduce” parameters are transformed. The dots ( . ) become underscores ( _ ). For example, mapreduce.job.id becomes mapreduce_job_id and mapreduce.job.jar becomes mapreduce_job_jar. To get the values in a streaming job’s mapper/reducer use the parameter names with the underscores.")]),e._v(" "),a("h4",{attrs:{id:"task-logs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task-logs"}},[e._v("#")]),e._v(" Task Logs")]),e._v(" "),a("p",[e._v("The standard output (stdout) and error (stderr) streams and the syslog of the task are read by the NodeManager and logged to ${HADOOP_LOG_DIR}/userlogs.")]),e._v(" "),a("h4",{attrs:{id:"distributing-libraries"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#distributing-libraries"}},[e._v("#")]),e._v(" Distributing Libraries")]),e._v(" "),a("p",[e._v("The DistributedCache can also be used to distribute both jars and native libraries for use in the map and/or reduce tasks. The child-jvm always has its current working directory added to the java.library.path and LD_LIBRARY_PATH. And hence the cached libraries can be loaded via "),a("a",{attrs:{href:"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("System.loadLibrary"),a("OutboundLink")],1),e._v(" or "),a("a",{attrs:{href:"http://docs.oracle.com/javase/7/docs/api/java/lang/System.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("System.load"),a("OutboundLink")],1),e._v(". More details on how to load shared libraries through distributed cache are documented at "),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/NativeLibraries.html#Native_Shared_Libraries"}},[e._v("Native Libraries")]),e._v(".")],1),e._v(" "),a("h3",{attrs:{id:"job-submission-and-monitoring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job-submission-and-monitoring"}},[e._v("#")]),e._v(" Job Submission and Monitoring")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job")]),e._v(" is the primary interface by which user-job interacts with the ResourceManager.")],1),e._v(" "),a("p",[e._v("Job provides facilities to submit jobs, track their progress, access component-tasks’ reports and logs, get the MapReduce cluster’s status information and so on.")]),e._v(" "),a("p",[e._v("The job submission process involves:")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Checking the input and output specifications of the job.")])]),e._v(" "),a("li",[a("p",[e._v("Computing the InputSplit values for the job.")])]),e._v(" "),a("li",[a("p",[e._v("Setting up the requisite accounting information for the DistributedCache of the job, if necessary.")])]),e._v(" "),a("li",[a("p",[e._v("Copying the job’s jar and configuration to the MapReduce system directory on the FileSystem.")])]),e._v(" "),a("li",[a("p",[e._v("Submitting the job to the ResourceManager and optionally monitoring it’s status.")])])]),e._v(" "),a("p",[e._v("Job history files are also logged to user specified directory mapreduce.jobhistory.intermediate-done-dir and mapreduce.jobhistory.done-dir, which defaults to job output directory.")]),e._v(" "),a("p",[e._v("User can view the history logs summary in specified directory using the following command $ mapred job -history output.jhist This command will print job details, failed and killed tip details. More details about the job such as successful tasks and task attempts made for each task can be viewed using the following command $ mapred job -history all output.jhist")]),e._v(" "),a("p",[e._v("Normally the user uses Job to create the application, describe various facets of the job, submit the job, and monitor its progress.")]),e._v(" "),a("h4",{attrs:{id:"job-control"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job-control"}},[e._v("#")]),e._v(" Job Control")]),e._v(" "),a("p",[e._v("Users may need to chain MapReduce jobs to accomplish complex tasks which cannot be done via a single MapReduce job. This is fairly easy since the output of the job typically goes to distributed file-system, and the output, in turn, can be used as the input for the next job.")]),e._v(" "),a("p",[e._v("However, this also means that the onus on ensuring jobs are complete (success/failure) lies squarely on the clients. In such cases, the various job-control options are:")]),e._v(" "),a("ul",[a("li",[a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.submit()")]),e._v(" : Submit the job to the cluster and return immediately.")],1)]),e._v(" "),a("li",[a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.waitForCompletion(boolean)")]),e._v(" : Submit the job to the cluster and wait for it to finish.")],1)])]),e._v(" "),a("h3",{attrs:{id:"job-input"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job-input"}},[e._v("#")]),e._v(" Job Input")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/InputFormat.html"}},[e._v("InputFormat")]),e._v(" describes the input-specification for a MapReduce job.")],1),e._v(" "),a("p",[e._v("The MapReduce framework relies on the InputFormat of the job to:")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Validate the input-specification of the job.")])]),e._v(" "),a("li",[a("p",[e._v("Split-up the input file(s) into logical InputSplit instances, each of which is then assigned to an individual Mapper.")])]),e._v(" "),a("li",[a("p",[e._v("Provide the RecordReader implementation used to glean input records from the logical InputSplit for processing by the Mapper.")])])]),e._v(" "),a("p",[e._v("The default behavior of file-based InputFormat implementations, typically sub-classes of "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/FileInputFormat.html"}},[e._v("FileInputFormat")]),e._v(", is to split the input into logical InputSplit instances based on the total size, in bytes, of the input files. However, the FileSystem blocksize of the input files is treated as an upper bound for input splits. A lower bound on the split size can be set via mapreduce.input.fileinputformat.split.minsize.")],1),e._v(" "),a("p",[e._v("Clearly, logical splits based on input-size is insufficient for many applications since record boundaries must be respected. In such cases, the application should implement a RecordReader, who is responsible for respecting record-boundaries and presents a record-oriented view of the logical InputSplit to the individual task.")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/TextInputFormat.html"}},[e._v("TextInputFormat")]),e._v(" is the default InputFormat.")],1),e._v(" "),a("p",[e._v("If TextInputFormat is the InputFormat for a given job, the framework detects input-files with the .gz extensions and automatically decompresses them using the appropriate CompressionCodec. However, it must be noted that compressed files with the above extensions cannot be split and each compressed file is processed in its entirety by a single mapper.")]),e._v(" "),a("h4",{attrs:{id:"inputsplit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inputsplit"}},[e._v("#")]),e._v(" InputSplit")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/InputSplit.html"}},[e._v("InputSplit")]),e._v(" represents the data to be processed by an individual Mapper.")],1),e._v(" "),a("p",[e._v("Typically InputSplit presents a byte-oriented view of the input, and it is the responsibility of RecordReader to process and present a record-oriented view.")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/input/FileSplit.html"}},[e._v("FileSplit")]),e._v(" is the default InputSplit. It sets mapreduce.map.input.file to the path of the input file for the logical split.")],1),e._v(" "),a("h4",{attrs:{id:"recordreader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recordreader"}},[e._v("#")]),e._v(" RecordReader")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/RecordReader.html"}},[e._v("RecordReader")]),e._v(" reads <key, value> pairs from an InputSplit.")],1),e._v(" "),a("p",[e._v("Typically the RecordReader converts the byte-oriented view of the input, provided by the InputSplit, and presents a record-oriented to the Mapper implementations for processing. RecordReader thus assumes the responsibility of processing record boundaries and presents the tasks with keys and values.")]),e._v(" "),a("h3",{attrs:{id:"job-output"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job-output"}},[e._v("#")]),e._v(" Job Output")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/OutputFormat.html"}},[e._v("OutputFormat")]),e._v(" describes the output-specification for a MapReduce job.")],1),e._v(" "),a("p",[e._v("The MapReduce framework relies on the OutputFormat of the job to:")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Validate the output-specification of the job; for example, check that the output directory doesn’t already exist.")])]),e._v(" "),a("li",[a("p",[e._v("Provide the RecordWriter implementation used to write the output files of the job. Output files are stored in a FileSystem.")])])]),e._v(" "),a("p",[e._v("TextOutputFormat is the default OutputFormat.")]),e._v(" "),a("h4",{attrs:{id:"outputcommitter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outputcommitter"}},[e._v("#")]),e._v(" OutputCommitter")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/OutputCommitter.html"}},[e._v("OutputCommitter")]),e._v(" describes the commit of task output for a MapReduce job.")],1),e._v(" "),a("p",[e._v("The MapReduce framework relies on the OutputCommitter of the job to:")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Setup the job during initialization. For example, create the temporary output directory for the job during the initialization of the job. Job setup is done by a separate task when the job is in PREP state and after initializing tasks. Once the setup task completes, the job will be moved to RUNNING state.")])]),e._v(" "),a("li",[a("p",[e._v("Cleanup the job after the job completion. For example, remove the temporary output directory after the job completion. Job cleanup is done by a separate task at the end of the job. Job is declared SUCCEDED/FAILED/KILLED after the cleanup task completes.")])]),e._v(" "),a("li",[a("p",[e._v("Setup the task temporary output. Task setup is done as part of the same task, during task initialization.")])]),e._v(" "),a("li",[a("p",[e._v("Check whether a task needs a commit. This is to avoid the commit procedure if a task does not need commit.")])]),e._v(" "),a("li",[a("p",[e._v("Commit of the task output. Once task is done, the task will commit it’s output if required.")])]),e._v(" "),a("li",[a("p",[e._v("Discard the task commit. If the task has been failed/killed, the output will be cleaned-up. If task could not cleanup (in exception block), a separate task will be launched with same attempt-id to do the cleanup.")])])]),e._v(" "),a("p",[e._v("FileOutputCommitter is the default OutputCommitter. Job setup/cleanup tasks occupy map or reduce containers, whichever is available on the NodeManager. And JobCleanup task, TaskCleanup tasks and JobSetup task have the highest priority, and in that order.")]),e._v(" "),a("h4",{attrs:{id:"task-side-effect-files"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task-side-effect-files"}},[e._v("#")]),e._v(" Task Side-Effect Files")]),e._v(" "),a("p",[e._v("In some applications, component tasks need to create and/or write to side-files, which differ from the actual job-output files.")]),e._v(" "),a("p",[e._v("In such cases there could be issues with two instances of the same Mapper or Reducer running simultaneously (for example, speculative tasks) trying to open and/or write to the same file (path) on the FileSystem. Hence the application-writer will have to pick unique names per task-attempt (using the attemptid, say attempt_200709221812_0001_m_000000_0), not just per task.")]),e._v(" "),a("p",[e._v("To avoid these issues the MapReduce framework, when the OutputCommitter is FileOutputCommitter, maintains a special ${mapreduce.output.fileoutputformat.outputdir}/"),a("em",[e._v("temporary/")]),e._v("${taskid} sub-directory accessible via ${mapreduce.task.output.dir} for each task-attempt on the FileSystem where the output of the task-attempt is stored. On successful completion of the task-attempt, the files in the ${mapreduce.output.fileoutputformat.outputdir}/"),a("em",[e._v("temporary/")]),e._v("${taskid} (only) are promoted to ${mapreduce.output.fileoutputformat.outputdir}. Of course, the framework discards the sub-directory of unsuccessful task-attempts. This process is completely transparent to the application.")]),e._v(" "),a("p",[e._v("The application-writer can take advantage of this feature by creating any side-files required in ${mapreduce.task.output.dir} during execution of a task via "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html"}},[e._v("FileOutputFormat.getWorkOutputPath(Conext)")]),e._v(", and the framework will promote them similarly for succesful task-attempts, thus eliminating the need to pick unique paths per task-attempt.")],1),e._v(" "),a("p",[e._v("Note: The value of ${mapreduce.task.output.dir} during execution of a particular task-attempt is actually ${mapreduce.output.fileoutputformat.outputdir}/"),a("em",[e._v("temporary/")]),e._v("{$taskid}, and this value is set by the MapReduce framework. So, just create any side-files in the path returned by "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html"}},[e._v("FileOutputFormat.getWorkOutputPath(Conext)")]),e._v(" from MapReduce task to take advantage of this feature.")],1),e._v(" "),a("p",[e._v("The entire discussion holds true for maps of jobs with reducer=NONE (i.e. 0 reduces) since output of the map, in that case, goes directly to HDFS.")]),e._v(" "),a("h4",{attrs:{id:"recordwriter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recordwriter"}},[e._v("#")]),e._v(" RecordWriter")]),e._v(" "),a("p",[a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/RecordWriter.html"}},[e._v("RecordWriter")]),e._v(" writes the output <key, value> pairs to an output file.")],1),e._v(" "),a("p",[e._v("RecordWriter implementations write the job outputs to the FileSystem.")]),e._v(" "),a("h3",{attrs:{id:"other-useful-features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#other-useful-features"}},[e._v("#")]),e._v(" Other Useful Features")]),e._v(" "),a("h4",{attrs:{id:"submitting-jobs-to-queues"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#submitting-jobs-to-queues"}},[e._v("#")]),e._v(" Submitting Jobs to Queues")]),e._v(" "),a("p",[e._v("Users submit jobs to Queues. Queues, as collection of jobs, allow the system to provide specific functionality. For example, queues use ACLs to control which users who can submit jobs to them. Queues are expected to be primarily used by Hadoop Schedulers.")]),e._v(" "),a("p",[e._v("Hadoop comes configured with a single mandatory queue, called ‘default’. Queue names are defined in the mapreduce.job.queuename property of the Hadoop site configuration. Some job schedulers, such as the "),a("router-link",{attrs:{to:"/en/docs/hadoop-yarn/hadoop-yarn-site/CapacityScheduler.html"}},[e._v("Capacity Scheduler")]),e._v(", support multiple queues.")],1),e._v(" "),a("p",[e._v("A job defines the queue it needs to be submitted to through the mapreduce.job.queuename property, or through the Configuration.set(MRJobConfig.QUEUE_NAME, String) API. Setting the queue name is optional. If a job is submitted without an associated queue name, it is submitted to the ‘default’ queue.")]),e._v(" "),a("h4",{attrs:{id:"counters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#counters"}},[e._v("#")]),e._v(" Counters")]),e._v(" "),a("p",[e._v("Counters represent global counters, defined either by the MapReduce framework or applications. Each Counter can be of any Enum type. Counters of a particular Enum are bunched into groups of type Counters.Group.")]),e._v(" "),a("p",[e._v("Applications can define arbitrary Counters (of type Enum) and update them via "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/Counters.html"}},[e._v("Counters.incrCounter(Enum, long)")]),e._v(" or Counters.incrCounter(String, String, long) in the map and/or reduce methods. These counters are then globally aggregated by the framework.")],1),e._v(" "),a("h4",{attrs:{id:"distributedcache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#distributedcache"}},[e._v("#")]),e._v(" DistributedCache")]),e._v(" "),a("p",[e._v("DistributedCache distributes application-specific, large, read-only files efficiently.")]),e._v(" "),a("p",[e._v("DistributedCache is a facility provided by the MapReduce framework to cache files (text, archives, jars and so on) needed by applications.")]),e._v(" "),a("p",[e._v("Applications specify the files to be cached via urls ("),a("a",{attrs:{href:"hdfs://)"}},[e._v("hdfs://)")]),e._v(" in the Job. The DistributedCache assumes that the files specified via "),a("router-link",{attrs:{to:"hdfs://"}},[e._v("hdfs://")]),e._v(" urls are already present on the FileSystem.")],1),e._v(" "),a("p",[e._v("The framework will copy the necessary files to the worker node before any tasks for the job are executed on that node. Its efficiency stems from the fact that the files are only copied once per job and the ability to cache archives which are un-archived on the workers.")]),e._v(" "),a("p",[e._v("DistributedCache tracks the modification timestamps of the cached files. Clearly the cache files should not be modified by the application or externally while the job is executing.")]),e._v(" "),a("p",[e._v("DistributedCache can be used to distribute simple, read-only data/text files and more complex types such as archives and jars. Archives (zip, tar, tgz and tar.gz files) are un-archived at the worker nodes. Files have execution permissions set.")]),e._v(" "),a("p",[e._v("The files/archives can be distributed by setting the property mapreduce.job.cache.{files |archives}. If more than one file/archive has to be distributed, they can be added as comma separated paths. The properties can also be set by APIs "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.addCacheFile(URI)")]),e._v("/ "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.addCacheArchive(URI)")]),e._v(" and "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setCacheFiles(URI[])")]),e._v("/ "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setCacheArchives(URI[])")]),e._v(" where URI is of the form hdfs://host:port/absolute-path#link-name. In Streaming, the files can be distributed through command line option -cacheFile/-cacheArchive.")],1),e._v(" "),a("p",[e._v("The DistributedCache can also be used as a rudimentary software distribution mechanism for use in the map and/or reduce tasks. It can be used to distribute both jars and native libraries. The "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.addArchiveToClassPath(Path)")]),e._v(" or "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.addFileToClassPath(Path)")]),e._v(" api can be used to cache files/jars and also add them to the classpath of child-jvm. The same can be done by setting the configuration properties mapreduce.job.classpath.{files |archives}. Similarly the cached files that are symlinked into the working directory of the task can be used to distribute native libraries and load them.")],1),e._v(" "),a("h5",{attrs:{id:"private-and-public-distributedcache-files"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#private-and-public-distributedcache-files"}},[e._v("#")]),e._v(" Private and Public DistributedCache Files")]),e._v(" "),a("p",[e._v("DistributedCache files can be private or public, that determines how they can be shared on the worker nodes.")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("“Private” DistributedCache files are cached in a localdirectory private to the user whose jobs need these files. These files are shared by all tasks and jobs of the specific user only and cannot be accessed by jobs of other users on the workers. A DistributedCache file becomes private by virtue of its permissions on the file system where the files are uploaded, typically HDFS. If the file has no world readable access, or if the directory path leading to the file has no world executable access for lookup, then the file becomes private.")])]),e._v(" "),a("li",[a("p",[e._v("“Public” DistributedCache files are cached in a global directory and the file access is setup such that they are publicly visible to all users. These files can be shared by tasks and jobs of all users on the workers. A DistributedCache file becomes public by virtue of its permissions on the file system where the files are uploaded, typically HDFS. If the file has world readable access, AND if the directory path leading to the file has world executable access for lookup, then the file becomes public. In other words, if the user intends to make a file publicly available to all users, the file permissions must be set to be world readable, and the directory permissions on the path leading to the file must be world executable.")])])]),e._v(" "),a("h4",{attrs:{id:"profiling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#profiling"}},[e._v("#")]),e._v(" Profiling")]),e._v(" "),a("p",[e._v("Profiling is a utility to get a representative (2 or 3) sample of built-in java profiler for a sample of maps and reduces.")]),e._v(" "),a("p",[e._v("User can specify whether the system should collect profiler information for some of the tasks in the job by setting the configuration property mapreduce.task.profile. The value can be set using the api Configuration.set(MRJobConfig.TASK_PROFILE, boolean). If the value is set true, the task profiling is enabled. The profiler information is stored in the user log directory. By default, profiling is not enabled for the job.")]),e._v(" "),a("p",[e._v("Once user configures that profiling is needed, she/he can use the configuration property mapreduce.task.profile.{maps|reduces} to set the ranges of MapReduce tasks to profile. The value can be set using the api Configuration.set(MRJobConfig.NUM_{MAP|REDUCE}_PROFILES, String). By default, the specified range is 0-2.")]),e._v(" "),a("p",[e._v("User can also specify the profiler configuration arguments by setting the configuration property mapreduce.task.profile.params. The value can be specified using the api Configuration.set(MRJobConfig.TASK_PROFILE_PARAMS, String). If the string contains a %s, it will be replaced with the name of the profiling output file when the task runs. These parameters are passed to the task child JVM on the command line. The default value for the profiling parameters is -agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s.")]),e._v(" "),a("h4",{attrs:{id:"debugging"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#debugging"}},[e._v("#")]),e._v(" Debugging")]),e._v(" "),a("p",[e._v("The MapReduce framework provides a facility to run user-provided scripts for debugging. When a MapReduce task fails, a user can run a debug script, to process task logs for example. The script is given access to the task’s stdout and stderr outputs, syslog and jobconf. The output from the debug script’s stdout and stderr is displayed on the console diagnostics and also as part of the job UI.")]),e._v(" "),a("p",[e._v("In the following sections we discuss how to submit a debug script with a job. The script file needs to be distributed and submitted to the framework.")]),e._v(" "),a("h5",{attrs:{id:"how-to-distribute-the-script-file"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-to-distribute-the-script-file"}},[e._v("#")]),e._v(" How to distribute the script file:")]),e._v(" "),a("p",[e._v("The user needs to use DistributedCache to distribute and symlink to the script file.")]),e._v(" "),a("h5",{attrs:{id:"how-to-submit-the-script"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-to-submit-the-script"}},[e._v("#")]),e._v(" How to submit the script:")]),e._v(" "),a("p",[e._v("A quick way to submit the debug script is to set values for the properties mapreduce.map.debug.script and mapreduce.reduce.debug.script, for debugging map and reduce tasks respectively. These properties can also be set by using APIs "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/conf/Configuration.html"}},[e._v("Configuration.set(MRJobConfig.MAP_DEBUG_SCRIPT, String)")]),e._v(" and "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/conf/Configuration.html"}},[e._v("Configuration.set(MRJobConfig.REDUCE_DEBUG_SCRIPT, String)")]),e._v(". In streaming mode, a debug script can be submitted with the command-line options -mapdebug and -reducedebug, for debugging map and reduce tasks respectively.")],1),e._v(" "),a("p",[e._v("The arguments to the script are the task’s stdout, stderr, syslog and jobconf files. The debug command, run on the node where the MapReduce task failed, is:"),a("br"),e._v("\n$script $stdout $stderr $syslog $jobconf")]),e._v(" "),a("p",[e._v("Pipes programs have the c++ program name as a fifth argument for the command. Thus for the pipes programs the command is"),a("br"),e._v("\n$script $stdout $stderr $syslog $jobconf $program")]),e._v(" "),a("h5",{attrs:{id:"default-behavior"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#default-behavior"}},[e._v("#")]),e._v(" Default Behavior:")]),e._v(" "),a("p",[e._v("For pipes, a default script is run to process core dumps under gdb, prints stack trace and gives info about running threads.")]),e._v(" "),a("h4",{attrs:{id:"data-compression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-compression"}},[e._v("#")]),e._v(" Data Compression")]),e._v(" "),a("p",[e._v("Hadoop MapReduce provides facilities for the application-writer to specify compression for both intermediate map-outputs and the job-outputs i.e. output of the reduces. It also comes bundled with "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/io/compress/CompressionCodec.html"}},[e._v("CompressionCodec")]),e._v(" implementation for the "),a("a",{attrs:{href:"http://www.zlib.net",target:"_blank",rel:"noopener noreferrer"}},[e._v("zlib"),a("OutboundLink")],1),e._v(" compression algorithm. The "),a("a",{attrs:{href:"http://www.gzip.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("gzip"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"http://www.bzip.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("bzip2"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"http://code.google.com/p/snappy/",target:"_blank",rel:"noopener noreferrer"}},[e._v("snappy"),a("OutboundLink")],1),e._v(", and "),a("a",{attrs:{href:"http://code.google.com/p/lz4/",target:"_blank",rel:"noopener noreferrer"}},[e._v("lz4"),a("OutboundLink")],1),e._v(" file format are also supported.")],1),e._v(" "),a("p",[e._v("Hadoop also provides native implementations of the above compression codecs for reasons of both performance (zlib) and non-availability of Java libraries. More details on their usage and availability are available "),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/NativeLibraries.html"}},[e._v("here")]),e._v(".")],1),e._v(" "),a("h5",{attrs:{id:"intermediate-outputs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#intermediate-outputs"}},[e._v("#")]),e._v(" Intermediate Outputs")]),e._v(" "),a("p",[e._v("Applications can control compression of intermediate map-outputs via the Configuration.set(MRJobConfig.MAP_OUTPUT_COMPRESS, boolean) api and the CompressionCodec to be used via the Configuration.set(MRJobConfig.MAP_OUTPUT_COMPRESS_CODEC, Class) api.")]),e._v(" "),a("h5",{attrs:{id:"job-outputs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#job-outputs"}},[e._v("#")]),e._v(" Job Outputs")]),e._v(" "),a("p",[e._v("Applications can control compression of job-outputs via the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/output/FileOutputFormat.html"}},[e._v("FileOutputFormat.setCompressOutput(Job, boolean)")]),e._v(" api and the CompressionCodec to be used can be specified via the FileOutputFormat.setOutputCompressorClass(Job, Class) api.")],1),e._v(" "),a("p",[e._v("If the job outputs are to be stored in the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/lib/output/SequenceFileOutputFormat.html"}},[e._v("SequenceFileOutputFormat")]),e._v(", the required SequenceFile.CompressionType (i.e. RECORD / BLOCK - defaults to RECORD) can be specified via the SequenceFileOutputFormat.setOutputCompressionType(Job, SequenceFile.CompressionType) api.")],1),e._v(" "),a("h4",{attrs:{id:"skipping-bad-records"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#skipping-bad-records"}},[e._v("#")]),e._v(" Skipping Bad Records")]),e._v(" "),a("p",[e._v("Hadoop provides an option where a certain set of bad input records can be skipped when processing map inputs. Applications can control this feature through the "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords")]),e._v(" class.")],1),e._v(" "),a("p",[e._v("This feature can be used when map tasks crash deterministically on certain input. This usually happens due to bugs in the map function. Usually, the user would have to fix these bugs. This is, however, not possible sometimes. The bug may be in third party libraries, for example, for which the source code is not available. In such cases, the task never completes successfully even after multiple attempts, and the job fails. With this feature, only a small portion of data surrounding the bad records is lost, which may be acceptable for some applications (those performing statistical analysis on very large data, for example).")]),e._v(" "),a("p",[e._v("By default this feature is disabled. For enabling it, refer to "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.setMapperMaxSkipRecords(Configuration, long)")]),e._v(" and "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.setReducerMaxSkipGroups(Configuration, long)")]),e._v(".")],1),e._v(" "),a("p",[e._v("With this feature enabled, the framework gets into ‘skipping mode’ after a certain number of map failures. For more details, see "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.setAttemptsToStartSkipping(Configuration, int)")]),e._v(". In ‘skipping mode’, map tasks maintain the range of records being processed. To do this, the framework relies on the processed record counter. See "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.COUNTER_MAP_PROCESSED_RECORDS")]),e._v(" and "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.COUNTER_REDUCE_PROCESSED_GROUPS")]),e._v(". This counter enables the framework to know how many records have been processed successfully, and hence, what record range caused a task to crash. On further attempts, this range of records is skipped.")],1),e._v(" "),a("p",[e._v("The number of records skipped depends on how frequently the processed record counter is incremented by the application. It is recommended that this counter be incremented after every record is processed. This may not be possible in some applications that typically batch their processing. In such cases, the framework may skip additional records surrounding the bad record. Users can control the number of skipped records through "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.setMapperMaxSkipRecords(Configuration, long)")]),e._v(" and "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.setReducerMaxSkipGroups(Configuration, long)")]),e._v(". The framework tries to narrow the range of skipped records using a binary search-like approach. The skipped range is divided into two halves and only one half gets executed. On subsequent failures, the framework figures out which half contains bad records. A task will be re-executed till the acceptable skipped value is met or all task attempts are exhausted. To increase the number of task attempts, use "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setMaxMapAttempts(int)")]),e._v(" and "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapreduce/Job.html"}},[e._v("Job.setMaxReduceAttempts(int)")])],1),e._v(" "),a("p",[e._v("Skipped records are written to HDFS in the sequence file format, for later analysis. The location can be changed through "),a("router-link",{attrs:{to:"/en/docs/api/org/apache/hadoop/mapred/SkipBadRecords.html"}},[e._v("SkipBadRecords.setSkipOutputPath(JobConf, Path)")]),e._v(".")],1),e._v(" "),a("h3",{attrs:{id:"example-wordcount-v2-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-wordcount-v2-0"}},[e._v("#")]),e._v(" Example: WordCount v2.0")]),e._v(" "),a("p",[e._v("Here is a more complete WordCount which uses many of the features provided by the MapReduce framework we discussed so far.")]),e._v(" "),a("p",[e._v("This needs the HDFS to be up and running, especially for the DistributedCache-related features. Hence it only works with a "),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/SingleCluster.html"}},[e._v("pseudo-distributed")]),e._v(" or "),a("router-link",{attrs:{to:"/en/docs/hadoop-project-dist/hadoop-common/ClusterSetup.html"}},[e._v("fully-distributed")]),e._v(" Hadoop installation.")],1),e._v(" "),a("h4",{attrs:{id:"source-code-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#source-code-2"}},[e._v("#")]),e._v(" Source Code")]),e._v(" "),a("pre",[a("code",[e._v('import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.Counter;\nimport org.apache.hadoop.util.GenericOptionsParser;\nimport org.apache.hadoop.util.StringUtils;\n\npublic class WordCount2 {\n\n  public static class TokenizerMapper\n       extends Mapper<Object, Text, Text, IntWritable>{\n\n    static enum CountersEnum { INPUT_WORDS }\n\n    private final static IntWritable one = new IntWritable(1);\n    private Text word = new Text();\n\n    private boolean caseSensitive;\n    private Set<String> patternsToSkip = new HashSet<String>();\n\n    private Configuration conf;\n    private BufferedReader fis;\n\n    @Override\n    public void setup(Context context) throws IOException,\n        InterruptedException {\n      conf = context.getConfiguration();\n      caseSensitive = conf.getBoolean("wordcount.case.sensitive", true);\n      if (conf.getBoolean("wordcount.skip.patterns", false)) {\n        URI[] patternsURIs = Job.getInstance(conf).getCacheFiles();\n        for (URI patternsURI : patternsURIs) {\n          Path patternsPath = new Path(patternsURI.getPath());\n          String patternsFileName = patternsPath.getName().toString();\n          parseSkipFile(patternsFileName);\n        }\n      }\n    }\n\n    private void parseSkipFile(String fileName) {\n      try {\n        fis = new BufferedReader(new FileReader(fileName));\n        String pattern = null;\n        while ((pattern = fis.readLine()) != null) {\n          patternsToSkip.add(pattern);\n        }\n      } catch (IOException ioe) {\n        System.err.println("Caught exception while parsing the cached file \'"\n            + StringUtils.stringifyException(ioe));\n      }\n    }\n\n    @Override\n    public void map(Object key, Text value, Context context\n                    ) throws IOException, InterruptedException {\n      String line = (caseSensitive) ?\n          value.toString() : value.toString().toLowerCase();\n      for (String pattern : patternsToSkip) {\n        line = line.replaceAll(pattern, "");\n      }\n      StringTokenizer itr = new StringTokenizer(line);\n      while (itr.hasMoreTokens()) {\n        word.set(itr.nextToken());\n        context.write(word, one);\n        Counter counter = context.getCounter(CountersEnum.class.getName(),\n            CountersEnum.INPUT_WORDS.toString());\n        counter.increment(1);\n      }\n    }\n  }\n\n  public static class IntSumReducer\n       extends Reducer<Text,IntWritable,Text,IntWritable> {\n    private IntWritable result = new IntWritable();\n\n    public void reduce(Text key, Iterable<IntWritable> values,\n                       Context context\n                       ) throws IOException, InterruptedException {\n      int sum = 0;\n      for (IntWritable val : values) {\n        sum += val.get();\n      }\n      result.set(sum);\n      context.write(key, result);\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    Configuration conf = new Configuration();\n    GenericOptionsParser optionParser = new GenericOptionsParser(conf, args);\n    String[] remainingArgs = optionParser.getRemainingArgs();\n    if ((remainingArgs.length != 2) && (remainingArgs.length != 4)) {\n      System.err.println("Usage: wordcount <in> <out> [-skip skipPatternFile]");\n      System.exit(2);\n    }\n    Job job = Job.getInstance(conf, "word count");\n    job.setJarByClass(WordCount2.class);\n    job.setMapperClass(TokenizerMapper.class);\n    job.setCombinerClass(IntSumReducer.class);\n    job.setReducerClass(IntSumReducer.class);\n    job.setOutputKeyClass(Text.class);\n    job.setOutputValueClass(IntWritable.class);\n\n    List<String> otherArgs = new ArrayList<String>();\n    for (int i=0; i < remainingArgs.length; ++i) {\n      if ("-skip".equals(remainingArgs[i])) {\n        job.addCacheFile(new Path(remainingArgs[++i]).toUri());\n        job.getConfiguration().setBoolean("wordcount.skip.patterns", true);\n      } else {\n        otherArgs.add(remainingArgs[i]);\n      }\n    }\n    FileInputFormat.addInputPath(job, new Path(otherArgs.get(0)));\n    FileOutputFormat.setOutputPath(job, new Path(otherArgs.get(1)));\n\n    System.exit(job.waitForCompletion(true) ? 0 : 1);\n  }\n}\n')])]),e._v(" "),a("h4",{attrs:{id:"sample-runs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sample-runs"}},[e._v("#")]),e._v(" Sample Runs")]),e._v(" "),a("p",[e._v("Sample text-files as input:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop fs -ls /user/joe/wordcount/input/\n/user/joe/wordcount/input/file01\n/user/joe/wordcount/input/file02\n\n$ bin/hadoop fs -cat /user/joe/wordcount/input/file01\nHello World, Bye World!\n\n$ bin/hadoop fs -cat /user/joe/wordcount/input/file02\nHello Hadoop, Goodbye to hadoop.\n")])]),e._v(" "),a("p",[e._v("Run the application:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop jar wc.jar WordCount2 /user/joe/wordcount/input /user/joe/wordcount/output\n")])]),e._v(" "),a("p",[e._v("Output:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000\nBye 1\nGoodbye 1\nHadoop, 1\nHello 2\nWorld! 1\nWorld, 1\nhadoop. 1\nto 1\n")])]),e._v(" "),a("p",[e._v("Notice that the inputs differ from the first version we looked at, and how they affect the outputs.")]),e._v(" "),a("p",[e._v("Now, lets plug-in a pattern-file which lists the word-patterns to be ignored, via the DistributedCache.")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop fs -cat /user/joe/wordcount/patterns.txt\n\\.\n\\,\n\\!\nto\n")])]),e._v(" "),a("p",[e._v("Run it again, this time with more options:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop jar wc.jar WordCount2 -Dwordcount.case.sensitive=true /user/joe/wordcount/input /user/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt\n")])]),e._v(" "),a("p",[e._v("As expected, the output:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000\nBye 1\nGoodbye 1\nHadoop 1\nHello 2\nWorld 2\nhadoop 1\n")])]),e._v(" "),a("p",[e._v("Run it once more, this time switch-off case-sensitivity:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop jar wc.jar WordCount2 -Dwordcount.case.sensitive=false /user/joe/wordcount/input /user/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt\n")])]),e._v(" "),a("p",[e._v("Sure enough, the output:")]),e._v(" "),a("pre",[a("code",[e._v("$ bin/hadoop fs -cat /user/joe/wordcount/output/part-r-00000\nbye 1\ngoodbye 1\nhadoop 2\nhello 2\nhorld 2\n")])]),e._v(" "),a("h4",{attrs:{id:"highlights"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#highlights"}},[e._v("#")]),e._v(" Highlights")]),e._v(" "),a("p",[e._v("The second version of WordCount improves upon the previous one by using some features offered by the MapReduce framework:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Demonstrates how applications can access configuration parameters in the setup method of the Mapper (and Reducer) implementations.")])]),e._v(" "),a("li",[a("p",[e._v("Demonstrates how the DistributedCache can be used to distribute read-only data needed by the jobs. Here it allows the user to specify word-patterns to skip while counting.")])]),e._v(" "),a("li",[a("p",[e._v("Demonstrates the utility of the GenericOptionsParser to handle generic Hadoop command-line options.")])]),e._v(" "),a("li",[a("p",[e._v("Demonstrates how applications can use Counters and how they can set application-specific status information passed to the map (and reduce) method.")])])]),e._v(" "),a("p",[e._v("Java and JNI are trademarks or registered trademarks of Oracle America, Inc. in the United States and other countries.")])])}),[],!1,null,null,null);t.default=r.exports}}]);