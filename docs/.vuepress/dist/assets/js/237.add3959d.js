(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{434:function(e,t,o){"use strict";o.r(t);var i=o(0),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"graceful-decommission-of-yarn-nodes"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#graceful-decommission-of-yarn-nodes"}},[e._v("#")]),e._v(" Graceful Decommission of YARN Nodes")]),e._v(" "),o("h2",{attrs:{id:"overview"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),o("p",[e._v("YARN is scalable very easily: any new NodeManager could join to the configured ResourceManager and start to execute jobs. But to achieve full elasticity we need a decommissioning process which helps to remove existing nodes and down-scale the cluster.")]),e._v(" "),o("p",[e._v("YARN Nodes could be decommissioned NORMAL or GRACEFUL.")]),e._v(" "),o("p",[e._v("Normal Decommission of YARN Nodes means an immediate shutdown.")]),e._v(" "),o("p",[e._v("Graceful Decommission of YARN Nodes is the mechanism to decommission NMs while minimize the impact to running applications. Once a node is in DECOMMISSIONING state, RM won’t schedule new containers on it and will wait for running containers and applications to complete (or until decommissioning timeout exceeded) before transition the node into DECOMMISSIONED.")]),e._v(" "),o("h2",{attrs:{id:"quick-start"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#quick-start"}},[e._v("#")]),e._v(" Quick start")]),e._v(" "),o("p",[e._v("To do a normal decommissioning:")]),e._v(" "),o("ol",[o("li",[e._v("Start a YARN cluster (with NodeManageres and ResourceManager)")]),e._v(" "),o("li",[e._v("Start a yarn job (for example with yarn jar... )")]),e._v(" "),o("li",[e._v("Add yarn.resourcemanager.nodes.exclude-path property to your yarn-site.xml (Note: you don’t need to restart the ResourceManager)")]),e._v(" "),o("li",[e._v("Create a text file (the location is defined in the previous step) with one line which contains the name of a selected NodeManager")]),e._v(" "),o("li",[e._v("Call ./bin/yarn rmadmin -refreshNodes")]),e._v(" "),o("li",[e._v("Result: The nodemanager is decommissioned immediately")])]),e._v(" "),o("p",[e._v("In the next sections we will cover some more detailed usage (for example: using graceful decommissioning with timeout).")]),e._v(" "),o("h2",{attrs:{id:"features"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#features"}},[e._v("#")]),e._v(" Features")]),e._v(" "),o("h3",{attrs:{id:"trigger-decommission-recommission-based-on-exclude-include-lists"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#trigger-decommission-recommission-based-on-exclude-include-lists"}},[e._v("#")]),e._v(" Trigger decommission/recommission based on exclude/include lists")]),e._v(" "),o("p",[e._v("yarn rmadmin -refreshNodes [-g [timeout in seconds] -client|server] notifies NodesListManager to detect and handle include and exclude hosts changes. NodesListManager loads excluded hosts from the exclude file as specified through the yarn.resourcemanager.nodes.exclude-path configuration in yarn-site.xml. (Note: It is unnecessary to restart RM in case of changing the exclude-path as this config will be read again for every refreshNodes command)")]),e._v(" "),o("p",[e._v("The format of the file could be plain text or XML depending the extension of the file. Only the XML format supports per node timout for graceful decommissioning.")]),e._v(" "),o("p",[e._v("NodesListManager inspects and compares status of RMNodes in resource manager and the exclude list, and apply necessary actions based on following rules:")]),e._v(" "),o("ul",[o("li",[e._v("Recommission DECOMMISSIONED or DECOMMISSIONING nodes that are no longer excluded;")]),e._v(" "),o("li",[e._v("Gracefully decommission excluded nodes that are not already in DECOMMISSIONED nor DECOMMISSIONING state;")]),e._v(" "),o("li",[e._v("Immediately decommission excluded nodes that are not already in DECOMMISSIONED state if -g flag is not specified.")])]),e._v(" "),o("p",[e._v("Accordingly, RECOMMISSION, GRACEFUL_DECOMMISSION or DECOMMISSION RMNodeEvent will be sent to the RMNode.")]),e._v(" "),o("h3",{attrs:{id:"per-node-decommission-timeout-support"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#per-node-decommission-timeout-support"}},[e._v("#")]),e._v(" Per-Node decommission timeout support")]),e._v(" "),o("p",[e._v("To support flexible graceful decommission of nodes using different timeout through single or multiple refreshNodes requests, HostsFileReader supports optional timeout value after each hostname (or ip) in the exclude host file.")]),e._v(" "),o("p",[e._v("The effective decommissioning timeout to use for a particular host is based on following priorities:")]),e._v(" "),o("p",[e._v("In case of server side timeout:")]),e._v(" "),o("ol",[o("li",[e._v("Use the timeout for the particular host if specified in exclude host file;")]),e._v(" "),o("li",[e._v("Use the timeout in yarn rmadmin -refreshNodes -g [timeout in seconds] -server|client if specified;")]),e._v(" "),o("li",[e._v("Use the default timeout specified through “yarn.resourcemanager.nodemanager-graceful-decommission-timeout-secs” configuration.")])]),e._v(" "),o("p",[e._v("In case of client side timout (see bellow):")]),e._v(" "),o("ol",[o("li",[e._v("Only the command line parameter defined by the -g flag will be used.")])]),e._v(" "),o("p",[e._v("NodesListManager decides the effective timeout to use and set it on individual RMNode. The timeout could also be dynamically adjusted through yarn rmadmin -refreshNodes -g [timeout in seconds] command. NodesListManager will resolve the effective timeout to use and update RMNode as necessary of the new timeout. Change of timeout does not reset the ongoing decommissioning but only affect the evaluation of whether the node has reached decommissioning timeout.")]),e._v(" "),o("p",[e._v("Here is a sample excludes file in xml format.")]),e._v(" "),o("pre",[o("code",[e._v('<?xml version="1.0"?>\n<hosts>\n  <host><name>host1</name></host>\n  <host><name>host2</name><timeout>123</timeout></host>\n  <host><name>host3</name><timeout>-1</timeout></host>\n  <host><name>host4, host5,host6</name><timeout>1800</timeout></host>\n</hosts>\n')])]),e._v(" "),o("p",[e._v("If the file extension of the exclude file is not xml, standard one-line-per-host format is used without timeout support.")]),e._v(" "),o("pre",[o("code",[e._v("host1\nhost2\nhost3\n")])]),e._v(" "),o("p",[e._v("Note: In the future more file formats are planned with timeout support. Follow the "),o("a",{attrs:{href:"https://issues.apache.org/jira/browse/YARN-5536",target:"_blank",rel:"noopener noreferrer"}},[e._v("YARN-5536"),o("OutboundLink")],1),e._v(" if you are interested.")]),e._v(" "),o("p",[e._v("Important to mention, that the timeout is not persited. In case of a RM restart/failover the node will be immediatelly decommission. (Follow the "),o("a",{attrs:{href:"https://issues.apache.org/jira/browse/YARN-5464",target:"_blank",rel:"noopener noreferrer"}},[e._v("YARN-5464"),o("OutboundLink")],1),e._v(" for changes in this behavior).")]),e._v(" "),o("h3",{attrs:{id:"client-or-server-side-timeout"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#client-or-server-side-timeout"}},[e._v("#")]),e._v(" Client or server side timeout")]),e._v(" "),o("p",[e._v("Timeout of Graceful decommissioning could be tracked on server or client side. The -client|server indicates if the timeout tracking should be handled by the client or the ResourceManager. The client side tracking is blocking, while the server-side tracking is not.")]),e._v(" "),o("h3",{attrs:{id:"rmnode-handles-decommission-events"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#rmnode-handles-decommission-events"}},[e._v("#")]),e._v(" RMNode handles decommission events")]),e._v(" "),o("p",[e._v("Upon receiving GRACEFUL_DECOMMISSION event, the RMNode will save the decommissioning timeout if specified, update metrics for graceful decommission and preserve its original total capacity, and transition into DECOMMISSIONING state.")]),e._v(" "),o("p",[e._v("Resources will be dynamically and periodically updated on DECOMMISSIONING RMNode so that scheduler won’t be scheduling new containers on them due to no available resources.")]),e._v(" "),o("h3",{attrs:{id:"automatic-and-asynchronous-tracking-of-decommissioning-nodes-status"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#automatic-and-asynchronous-tracking-of-decommissioning-nodes-status"}},[e._v("#")]),e._v(" Automatic and asynchronous tracking of decommissioning nodes status")]),e._v(" "),o("p",[e._v("DecommissioningNodeWatcher is the YARN component that tracks DECOMMISSIONING nodes status automatically and asynchronously after client/admin made the graceful decommission request. NM periodically send RM heart beat with it latest container status. DecommissioningNodeWatcher tracks heartbeat updates on all DECOMMISSIONING nodes to decide when, after all running containers on the node have completed, will be transitioned into DECOMMISSIONED state after which NodeManager will be told to shutdown.")]),e._v(" "),o("p",[e._v("Under MR application, a node, after completes all its containers, may still serve it map output data during the duration of the application for reducers. The YARN graceful decommission mechanism keeps such DECOMMISSIONING nodes until all involved applications complete. It could be however undesirable under long-running applications scenario where a bunch of “idle” nodes might stay around for long period of time. DecommissioningNodeWatcher balances such concern with a timeout — a DECOMMISSIONING node will be DECOMMISSIONED no later than decommissioning timeout regardless of running containers or applications. If running containers finished earlier, it continues waiting for applications to finish until the decommissioning timeout. When decommissioning timeout reaches, the node will be decommissioned regardless. The node will be deactivated and owning tasks will be rescheduled as necessary.")]),e._v(" "),o("p",[e._v("Status of all decommissioning node are logged periodically (every 20 seconds) in resource manager logs. Following are the sub-status of a decommissioning node:")]),e._v(" "),o("ul",[o("li",[e._v("NONE — Node is not in DECOMMISSIONING state.")]),e._v(" "),o("li",[e._v("WAIT_CONTAINER — Wait for running containers to complete.")]),e._v(" "),o("li",[e._v("WAIT_APP — Wait for running application to complete (after all containers complete)")]),e._v(" "),o("li",[e._v("TIMEOUT — Timeout waiting for either containers or applications to complete")]),e._v(" "),o("li",[e._v("READY — Nothing to wait, ready to be decommissioned")]),e._v(" "),o("li",[e._v("DECOMMISSIONED — The node has already been decommissioned")])]),e._v(" "),o("h2",{attrs:{id:"configuration"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#configuration"}},[e._v("#")]),e._v(" Configuration")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th",[e._v("Property")]),e._v(" "),o("th",[e._v("Value")])])]),e._v(" "),o("tbody",[o("tr",[o("td",[e._v("yarn.resourcemanager.nodemanager-graceful-decommission-timeout-secs")]),e._v(" "),o("td",[e._v("Timeout in seconds for YARN node graceful decommission. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.")])]),e._v(" "),o("tr",[o("td",[e._v("yarn.resourcemanager.decommissioning-nodes-watcher.poll-interval-secs")]),e._v(" "),o("td",[e._v("Period in seconds of the poll timer task inside DecommissioningNodesWatcher to identify and take care of DECOMMISSIONING nodes missing regular heart beat. The default value is 20 seconds.")])]),e._v(" "),o("tr",[o("td",[e._v("yarn.resourcemanager.nodes.exclude-path")]),e._v(" "),o("td",[e._v("Path to file with nodes to exclude.")])]),e._v(" "),o("tr",[o("td",[e._v("yarn.resourcemanager.nodes.include-path")]),e._v(" "),o("td",[e._v("Path to file with nodes to include.")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);