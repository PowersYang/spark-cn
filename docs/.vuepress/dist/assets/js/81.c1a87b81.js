(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{281:function(e,a,t){"use strict";t.r(a);var o=t(0),n=Object(o.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"hdfs-upgrade-domain"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hdfs-upgrade-domain","aria-hidden":"true"}},[e._v("#")]),e._v(" HDFS Upgrade Domain")]),e._v(" "),t("h2",{attrs:{id:"introduction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#introduction","aria-hidden":"true"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),t("p",[e._v("The current default HDFS block placement policy guarantees that a block’s 3 replicas will be placed on at least 2 racks. Specifically one replica is placed on one rack and the other two replicas are placed on another rack during write pipeline. This is a good compromise between rack diversity and write-pipeline efficiency. Note that subsequent load balancing or machine membership change might cause 3 replicas of a block to be distributed across 3 different racks. Thus any 3 datanodes in different racks could store 3 replicas of a block.")]),e._v(" "),t("p",[e._v("However, the default placement policy impacts how we should perform datanode rolling upgrade. "),t("router-link",{attrs:{to:"/docs/hadoop-project-dist/hadoop-hdfs/HdfsRollingUpgrade.html"}},[e._v("HDFS Rolling Upgrade document")]),e._v(" explains how the datanodes can be upgraded in a rolling fashion without downtime. Because any 3 datanodes in different racks could store all the replicas of a block, it is important to perform sequential restart of datanodes one at a time in order to minimize the impact on data availability and read/write operations. Upgrading one rack at a time is another option; but that will increase the chance of data unavailability if there is machine failure at another rack during the upgrade.")],1),e._v(" "),t("p",[e._v("The side effect of this sequential datanode rolling upgrade strategy is longer upgrade duration for larger clusters.")]),e._v(" "),t("h2",{attrs:{id:"architecture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#architecture","aria-hidden":"true"}},[e._v("#")]),e._v(" Architecture")]),e._v(" "),t("p",[e._v("To address the limitation of block placement policy on rolling upgrade, the concept of upgrade domain has been added to HDFS via a new block placement policy. The idea is to group datanodes in a new dimension called upgrade domain, in addition to the existing rack-based grouping. For example, we can assign all datanodes in the first position of any rack to upgrade domain ud_01, nodes in the second position to upgrade domain ud_02 and so on.")]),e._v(" "),t("p",[e._v("The namenode provides BlockPlacementPolicy interface to support any custom block placement besides the default block placement policy. A new upgrade domain block placement policy based on this interface is available in HDFS. It will make sure replicas of any given block are distributed across machines from different upgrade domains. By default, 3 replicas of any given block are placed on 3 different upgrade domains. This means all datanodes belonging to a specific upgrade domain collectively won’t store more than one replica of any block.")]),e._v(" "),t("p",[e._v("With upgrade domain block placement policy in place, we can upgrade all datanodes belonging to one upgrade domain at the same time without impacting data availability. Only after finishing upgrading one upgrade domain we move to the next upgrade domain until all upgrade domains have been upgraded. Such procedure will ensure no two replicas of any given block will be upgraded at the same time. This means we can upgrade many machines at the same time for a large cluster. And as the cluster continues to scale, new machines will be added to the existing upgrade domains without impact the parallelism of the upgrade.")]),e._v(" "),t("p",[e._v("For an existing cluster with the default block placement policy, after switching to the new upgrade domain block placement policy, any newly created blocks will conform the new policy. The old blocks allocated based on the old policy need to migrated the new policy. There is a migrator tool you can use. See HDFS-8789 for details.")]),e._v(" "),t("h2",{attrs:{id:"settings"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#settings","aria-hidden":"true"}},[e._v("#")]),e._v(" Settings")]),e._v(" "),t("p",[e._v("To enable upgrade domain on your clusters, please follow these steps:")]),e._v(" "),t("h3",{attrs:{id:"upgrade-domain-id-assignment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#upgrade-domain-id-assignment","aria-hidden":"true"}},[e._v("#")]),e._v(" Upgrade domain id assignment")]),e._v(" "),t("p",[e._v("How a datanode maps to an upgrade domain id is defined by administrators and specific to the cluster layout. A common way to use the rack position of the machine as its upgrade domain id.")]),e._v(" "),t("p",[e._v("To configure mapping from host name to its upgrade domain id, we need to use json-based host configuration file. by setting the following property as explained in "),t("a",{attrs:{href:"./hdfs-default.xml"}},[e._v("hdfs-default.xml")]),e._v(".")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Setting")]),e._v(" "),t("th",[e._v("Value")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("dfs.namenode.hosts.provider.classname")]),e._v(" "),t("td",[e._v("org.apache.hadoop.hdfs.server.blockmanagement.CombinedHostFileManager")])]),e._v(" "),t("tr",[t("td",[e._v("dfs.hosts")]),e._v(" "),t("td",[e._v("the path of the json hosts file")])])])]),e._v(" "),t("p",[e._v("The json hosts file defines the property for all hosts. In the following example, there are 4 datanodes in 2 racks; the machines at rack position 01 belong to upgrade domain 01; the machines at rack position 02 belong to upgrade domain 02.")]),e._v(" "),t("pre",[t("code",[e._v('[\n  {\n    "hostName": "dcA­rackA­01",\n    "upgradeDomain": "01"\n  },\n  {\n    "hostName": "dcA­rackA­02",\n    "upgradeDomain": "02"\n  },\n  {\n    "hostName": "dcA­rackB­01",\n    "upgradeDomain": "01"\n  },\n  {\n    "hostName": "dcA­rackB­02",\n    "upgradeDomain": "02"\n  }\n]\n')])]),e._v(" "),t("h3",{attrs:{id:"enable-upgrade-domain-block-placement-policy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#enable-upgrade-domain-block-placement-policy","aria-hidden":"true"}},[e._v("#")]),e._v(" Enable upgrade domain block placement policy")]),e._v(" "),t("p",[e._v("After each datanode has been assigned an upgrade domain id, the next step is to enable upgrade domain block placement policy with the following configuration as explained in "),t("a",{attrs:{href:"./hdfs-default.xml"}},[e._v("hdfs-default.xml")]),e._v(".")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("Setting")]),e._v(" "),t("th",[e._v("Value")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("dfs.block.replicator.classname")]),e._v(" "),t("td",[e._v("org.apache.hadoop.hdfs.server.blockmanagement.BlockPlacementPolicyWithUpgradeDomain")])])])]),e._v(" "),t("p",[e._v("After restarting of namenode, the new policy will be used for any new block allocation.")]),e._v(" "),t("h3",{attrs:{id:"migration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#migration","aria-hidden":"true"}},[e._v("#")]),e._v(" Migration")]),e._v(" "),t("p",[e._v("If you change the block placement policy of an existing cluster, you will need to make sure the blocks allocated prior to the block placement policy change conform the new block placement policy.")]),e._v(" "),t("p",[e._v("HDFS-8789 provides the initial draft patch of a client-side migration tool. After the tool is committed, we will be able to describe how to use the tool.")]),e._v(" "),t("h2",{attrs:{id:"rolling-restart-based-on-upgrade-domains"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rolling-restart-based-on-upgrade-domains","aria-hidden":"true"}},[e._v("#")]),e._v(" Rolling restart based on upgrade domains")]),e._v(" "),t("p",[e._v("During cluster administration, we might need to restart datanodes to pick up new configuration, new hadoop release or JVM version and so on. With upgrade domains enabled and all blocks on the cluster conform to the new policy, we can now restart datanodes in batches, one upgrade domain at a time. Whether it is manual process or via automation, the steps are")]),e._v(" "),t("ul",[t("li",[e._v("Group datanodes by upgrade domains based on dfsadmin or JMX’s datanode information.")]),e._v(" "),t("li",[e._v("For each upgrade domain\n"),t("ul",[t("li",[e._v("(Optional) put all the nodes in that upgrade domain to maintenance state (refer to "),t("router-link",{attrs:{to:"/docs/hadoop-project-dist/hadoop-hdfs/HdfsDataNodeAdminGuide.html"}},[e._v("HdfsDataNodeAdminGuide.html")]),e._v(").")],1),e._v(" "),t("li",[e._v("Restart all those nodes.")]),e._v(" "),t("li",[e._v("Check if all datanodes are healthy after restart. Unhealthy nodes should be decommissioned.")]),e._v(" "),t("li",[e._v("(Optional) Take all those nodes out of maintenance state.")])])])]),e._v(" "),t("h2",{attrs:{id:"metrics"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#metrics","aria-hidden":"true"}},[e._v("#")]),e._v(" Metrics")]),e._v(" "),t("p",[e._v("Upgrade domains are part of namenode’s JMX. As explained in "),t("router-link",{attrs:{to:"/docs/hadoop-project-dist/hadoop-hdfs/HDFSCommands.html"}},[e._v("HDFSCommands.html")]),e._v(", you can also verify upgrade domains using the following commands.")],1),e._v(" "),t("p",[e._v("Use dfsadmin to check upgrade domains at the cluster level.")]),e._v(" "),t("p",[e._v("hdfs dfsadmin -report")]),e._v(" "),t("p",[e._v("Use fsck to check upgrade domains of datanodes storing data at a specific path.")]),e._v(" "),t("p",[e._v("hdfs fsck "),t("path",[e._v(" -files -blocks -upgradedomains")])])])}),[],!1,null,null,null);a.default=n.exports}}]);